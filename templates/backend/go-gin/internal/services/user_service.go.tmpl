package services

import (
	"errors"
	"fmt"

	"{{.Name}}/internal/models"
	"{{.Name}}/internal/repositories"
)

// UserService defines the interface for user operations
type UserService interface {
	Create(req *models.UserCreateRequest) (*models.User, error)
	GetByID(id uint) (*models.User, error)
	GetByEmail(email string) (*models.User, error)
	GetByUsername(username string) (*models.User, error)
	Update(id uint, req *models.UserUpdateRequest) (*models.User, error)
	Delete(id uint) error
	List(offset, limit int) ([]*models.User, int64, error)
	AssignRole(userID, roleID uint) error
	RemoveRole(userID, roleID uint) error
}

// userService implements UserService
type userService struct {
	userRepo repositories.UserRepository
	roleRepo repositories.RoleRepository
}

// NewUserService creates a new user service
func NewUserService(userRepo repositories.UserRepository, roleRepo repositories.RoleRepository) UserService {
	return &userService{
		userRepo: userRepo,
		roleRepo: roleRepo,
	}
}

// Create creates a new user
func (s *userService) Create(req *models.UserCreateRequest) (*models.User, error) {
	// Check if user already exists
	if _, err := s.userRepo.GetByEmail(req.Email); err == nil {
		return nil, errors.New("user with this email already exists")
	}

	if _, err := s.userRepo.GetByUsername(req.Username); err == nil {
		return nil, errors.New("user with this username already exists")
	}

	user := &models.User{
		Email:     req.Email,
		Username:  req.Username,
		Password:  req.Password,
		FirstName: req.FirstName,
		LastName:  req.LastName,
		IsActive:  true,
		IsAdmin:   false,
	}

	return s.userRepo.Create(user)
}

// GetByID gets a user by ID
func (s *userService) GetByID(id uint) (*models.User, error) {
	return s.userRepo.GetByID(id)
}

// GetByEmail gets a user by email
func (s *userService) GetByEmail(email string) (*models.User, error) {
	return s.userRepo.GetByEmail(email)
}

// GetByUsername gets a user by username
func (s *userService) GetByUsername(username string) (*models.User, error) {
	return s.userRepo.GetByUsername(username)
}

// Update updates a user
func (s *userService) Update(id uint, req *models.UserUpdateRequest) (*models.User, error) {
	user, err := s.userRepo.GetByID(id)
	if err != nil {
		return nil, err
	}

	// Check for email uniqueness if email is being updated
	if req.Email != nil && *req.Email != user.Email {
		if _, err := s.userRepo.GetByEmail(*req.Email); err == nil {
			return nil, errors.New("user with this email already exists")
		}
		user.Email = *req.Email
	}

	// Check for username uniqueness if username is being updated
	if req.Username != nil && *req.Username != user.Username {
		if _, err := s.userRepo.GetByUsername(*req.Username); err == nil {
			return nil, errors.New("user with this username already exists")
		}
		user.Username = *req.Username
	}

	if req.FirstName != nil {
		user.FirstName = *req.FirstName
	}
	if req.LastName != nil {
		user.LastName = *req.LastName
	}
	if req.IsActive != nil {
		user.IsActive = *req.IsActive
	}

	return s.userRepo.Update(user)
}

// Delete deletes a user
func (s *userService) Delete(id uint) error {
	return s.userRepo.Delete(id)
}

// List lists users with pagination
func (s *userService) List(offset, limit int) ([]*models.User, int64, error) {
	return s.userRepo.List(offset, limit)
}

// AssignRole assigns a role to a user
func (s *userService) AssignRole(userID, roleID uint) error {
	user, err := s.userRepo.GetByID(userID)
	if err != nil {
		return fmt.Errorf("user not found: %w", err)
	}

	role, err := s.roleRepo.GetByID(roleID)
	if err != nil {
		return fmt.Errorf("role not found: %w", err)
	}

	// Check if user already has this role
	for _, userRole := range user.Roles {
		if userRole.ID == roleID {
			return errors.New("user already has this role")
		}
	}

	return s.userRepo.AssignRole(userID, roleID)
}

// RemoveRole removes a role from a user
func (s *userService) RemoveRole(userID, roleID uint) error {
	user, err := s.userRepo.GetByID(userID)
	if err != nil {
		return fmt.Errorf("user not found: %w", err)
	}

	// Check if user has this role
	hasRole := false
	for _, userRole := range user.Roles {
		if userRole.ID == roleID {
			hasRole = true
			break
		}
	}

	if !hasRole {
		return errors.New("user does not have this role")
	}

	return s.userRepo.RemoveRole(userID, roleID)
}