#!/bin/bash

# {{.Name}} - Health Check Script
# This script performs health checks on all services

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
PROJECT_NAME="{{.Name}}"
TIMEOUT=30
RETRY_COUNT=3
RETRY_DELAY=5

# Functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if service is healthy
check_service_health() {
    local service_name=$1
    local health_url=$2
    local expected_status=${3:-200}
    
    log_info "Checking health of ${service_name}..."
    
    for i in $(seq 1 ${RETRY_COUNT}); do
        if curl -f -s --max-time ${TIMEOUT} "${health_url}" > /dev/null 2>&1; then
            local status_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time ${TIMEOUT} "${health_url}")
            if [ "${status_code}" = "${expected_status}" ]; then
                log_success "${service_name} is healthy (HTTP ${status_code})"
                return 0
            else
                log_warning "${service_name} returned HTTP ${status_code}, expected ${expected_status}"
            fi
        else
            log_warning "${service_name} health check failed (attempt ${i}/${RETRY_COUNT})"
        fi
        
        if [ ${i} -lt ${RETRY_COUNT} ]; then
            sleep ${RETRY_DELAY}
        fi
    done
    
    log_error "${service_name} is unhealthy after ${RETRY_COUNT} attempts"
    return 1
}

# Check database connectivity
check_database() {
    log_info "Checking database connectivity..."
    
    local db_host="${DB_HOST:-localhost}"
    local db_port="${DB_PORT:-5432}"
    local db_user="${DB_USER:-{{.Name}}_user}"
    local db_name="${DB_NAME:-{{.Name}}_dev}"
    
    if command -v pg_isready &> /dev/null; then
        if pg_isready -h "${db_host}" -p "${db_port}" -U "${db_user}" -d "${db_name}" -t ${TIMEOUT}; then
            log_success "Database is ready"
            return 0
        else
            log_error "Database is not ready"
            return 1
        fi
    else
        # Fallback to netcat if pg_isready is not available
        if nc -z "${db_host}" "${db_port}"; then
            log_success "Database port is open"
            return 0
        else
            log_error "Database port is not accessible"
            return 1
        fi
    fi
}

# Check Redis connectivity
check_redis() {
    log_info "Checking Redis connectivity..."
    
    local redis_host="${REDIS_HOST:-localhost}"
    local redis_port="${REDIS_PORT:-6379}"
    
    if command -v redis-cli &> /dev/null; then
        if timeout ${TIMEOUT} redis-cli -h "${redis_host}" -p "${redis_port}" ping | grep -q "PONG"; then
            log_success "Redis is ready"
            return 0
        else
            log_error "Redis is not ready"
            return 1
        fi
    else
        # Fallback to netcat if redis-cli is not available
        if nc -z "${redis_host}" "${redis_port}"; then
            log_success "Redis port is open"
            return 0
        else
            log_error "Redis port is not accessible"
            return 1
        fi
    fi
}

# Check Docker containers
check_containers() {
    log_info "Checking Docker containers..."
    
    local unhealthy_containers=()
    
    # Get all containers for the project
    local containers=$(docker ps --filter "name=${PROJECT_NAME}" --format "table {{.Name}}\thealthy" | tail -n +2)
    
    if [ -z "${containers}" ]; then
        log_warning "No containers found for project ${PROJECT_NAME}"
        return 1
    fi
    
    while IFS=$'\t' read -r name status; do
        if [[ "${status}" == *"healthy"* ]] || [[ "${status}" == *"Up"* && "${status}" != *"unhealthy"* ]]; then
            log_success "Container ${name} is healthy"
        else
            log_error "Container ${name} is unhealthy: ${status}"
            unhealthy_containers+=("${name}")
        fi
    done <<< "${containers}"
    
    if [ ${#unhealthy_containers[@]} -eq 0 ]; then
        return 0
    else
        log_error "Unhealthy containers: ${unhealthy_containers[*]}"
        return 1
    fi
}

# Comprehensive health check
comprehensive_health_check() {
    log_info "Starting comprehensive health check for ${PROJECT_NAME}..."
    
    local failed_checks=0
    
    # Check containers first
    if ! check_containers; then
        ((failed_checks++))
    fi
    
    # Check database
    if ! check_database; then
        ((failed_checks++))
    fi
    
    # Check Redis
    if ! check_redis; then
        ((failed_checks++))
    fi
    
    {{if .Components.Frontend.MainApp}}
    # Check App frontend
    if ! check_service_health "App Frontend" "http://localhost:3000/api/health"; then
        ((failed_checks++))
    fi
    {{end}}
    
    {{if .Components.Frontend.Home}}
    # Check Home frontend
    if ! check_service_health "Home Frontend" "http://localhost:3001/api/health"; then
        ((failed_checks++))
    fi
    {{end}}
    
    {{if .Components.Frontend.Admin}}
    # Check Admin frontend
    if ! check_service_health "Admin Frontend" "http://localhost:3002/api/health"; then
        ((failed_checks++))
    fi
    {{end}}
    
    {{if .Components.Backend.API}}
    # Check Backend API
    if ! check_service_health "Backend API" "http://localhost:8080/health"; then
        ((failed_checks++))
    fi
    {{end}}
    
    # Summary
    if [ ${failed_checks} -eq 0 ]; then
        log_success "All health checks passed!"
        return 0
    else
        log_error "${failed_checks} health check(s) failed"
        return 1
    fi
}

# Show service metrics
show_metrics() {
    log_info "Service Metrics:"
    
    # Docker stats
    echo "Container Resource Usage:"
    docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}\t{{.BlockIO}}"
    
    echo ""
    
    # Disk usage
    echo "Disk Usage:"
    df -h | grep -E "(Filesystem|/dev/)"
    
    echo ""
    
    # Memory usage
    echo "Memory Usage:"
    free -h
}

# Main function
main() {
    local command="${1:-health}"
    
    case "${command}" in
        "health"|"check")
            comprehensive_health_check
            ;;
        "containers")
            check_containers
            ;;
        "database"|"db")
            check_database
            ;;
        "redis")
            check_redis
            ;;
        "metrics")
            show_metrics
            ;;
        "help"|"-h"|"--help")
            echo "Usage: $0 [COMMAND]"
            echo ""
            echo "Commands:"
            echo "  health      Run comprehensive health check (default)"
            echo "  containers  Check Docker containers only"
            echo "  database    Check database connectivity only"
            echo "  redis       Check Redis connectivity only"
            echo "  metrics     Show service metrics"
            echo "  help        Show this help"
            ;;
        *)
            log_error "Unknown command: ${command}"
            echo "Use '$0 help' for usage information"
            exit 1
            ;;
    esac
}

# Script execution
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi