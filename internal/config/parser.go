package config

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"

	"github.com/cuesoftinc/open-source-project-generator/pkg/models"
)

// Parser handles parsing of project configuration files
type Parser struct {
	// SupportedFormats lists the file formats that can be parsed
	SupportedFormats []string
}

// NewParser creates a new configuration parser
func NewParser() *Parser {
	return &Parser{
		SupportedFormats: []string{"yaml", "yml", "json"},
	}
}

// ParseFile parses a configuration file from the given path
func (p *Parser) ParseFile(path string) (*models.ProjectConfig, error) {
	// Check if file exists
	if _, err := os.Stat(path); os.IsNotExist(err) {
		return nil, fmt.Errorf("configuration file not found: %s", path)
	}

	// Open file
	file, err := os.Open(path) // #nosec G304 - Path is validated by caller and comes from CLI args
	if err != nil {
		return nil, fmt.Errorf("failed to open configuration file: %w", err)
	}
	defer func() {
		if closeErr := file.Close(); closeErr != nil {
			// Log the error but don't override the main return error
			// In production, this would use a logger
			_ = closeErr
		}
	}()

	// Determine format from file extension
	format := p.detectFormat(path)
	if format == "" {
		return nil, fmt.Errorf("unsupported file format: %s (supported: %s)",
			filepath.Ext(path), strings.Join(p.SupportedFormats, ", "))
	}

	// Parse based on format
	return p.Parse(file, format)
}

// Parse parses configuration from an io.Reader with the specified format
func (p *Parser) Parse(reader io.Reader, format string) (*models.ProjectConfig, error) {
	// Read all content
	data, err := io.ReadAll(reader)
	if err != nil {
		return nil, fmt.Errorf("failed to read configuration: %w", err)
	}

	// Parse based on format
	var config models.ProjectConfig

	switch strings.ToLower(format) {
	case "yaml", "yml":
		if err := yaml.Unmarshal(data, &config); err != nil {
			return nil, fmt.Errorf("failed to parse YAML configuration: %w", err)
		}
	case "json":
		if err := json.Unmarshal(data, &config); err != nil {
			return nil, fmt.Errorf("failed to parse JSON configuration: %w", err)
		}
	default:
		return nil, fmt.Errorf("unsupported format: %s", format)
	}

	return &config, nil
}

// ParseStdin parses configuration from standard input
func (p *Parser) ParseStdin(format string) (*models.ProjectConfig, error) {
	if format == "" {
		// Default to YAML for stdin
		format = "yaml"
	}

	return p.Parse(os.Stdin, format)
}

// ParseString parses configuration from a string
func (p *Parser) ParseString(content string, format string) (*models.ProjectConfig, error) {
	return p.Parse(strings.NewReader(content), format)
}

// detectFormat detects the configuration format from file extension
func (p *Parser) detectFormat(path string) string {
	ext := strings.TrimPrefix(filepath.Ext(path), ".")
	ext = strings.ToLower(ext)

	for _, supported := range p.SupportedFormats {
		if ext == supported {
			return ext
		}
	}

	return ""
}

// IsSupportedFormat checks if a format is supported
func (p *Parser) IsSupportedFormat(format string) bool {
	format = strings.ToLower(format)
	for _, supported := range p.SupportedFormats {
		if format == supported {
			return true
		}
	}
	return false
}

// GenerateTemplate generates a configuration template file
func (p *Parser) GenerateTemplate(format string) (string, error) {
	if !p.IsSupportedFormat(format) {
		return "", fmt.Errorf("unsupported format: %s", format)
	}

	// Create a template configuration with examples
	template := &models.ProjectConfig{
		Name:        "my-project",
		Description: "A sample project generated by the Open Source Project Generator",
		OutputDir:   "./my-project",
		Components: []models.ComponentConfig{
			{
				Type:    "nextjs",
				Name:    "web-app",
				Enabled: true,
				Config: map[string]interface{}{
					"name":       "web-app",
					"typescript": true,
					"tailwind":   true,
					"app_router": true,
					"eslint":     true,
				},
			},
			{
				Type:    "go-backend",
				Name:    "api-server",
				Enabled: true,
				Config: map[string]interface{}{
					"name":      "api-server",
					"module":    "github.com/user/my-project",
					"framework": "gin",
					"port":      8080,
				},
			},
			{
				Type:    "android",
				Name:    "mobile-android",
				Enabled: false,
				Config: map[string]interface{}{
					"name":       "mobile-android",
					"package":    "com.example.myproject",
					"min_sdk":    24,
					"target_sdk": 34,
					"language":   "kotlin",
				},
			},
			{
				Type:    "ios",
				Name:    "mobile-ios",
				Enabled: false,
				Config: map[string]interface{}{
					"name":              "mobile-ios",
					"bundle_id":         "com.example.myproject",
					"deployment_target": "15.0",
					"language":          "swift",
				},
			},
		},
		Integration: models.IntegrationConfig{
			GenerateDockerCompose: true,
			GenerateScripts:       true,
			APIEndpoints: map[string]string{
				"backend": "http://localhost:8080",
			},
			SharedEnvironment: map[string]string{
				"NODE_ENV":  "development",
				"LOG_LEVEL": "info",
			},
		},
		Options: models.ProjectOptions{
			UseExternalTools: true,
			DryRun:           false,
			Verbose:          false,
			CreateBackup:     true,
			ForceOverwrite:   false,
		},
	}

	// Marshal to requested format
	var data []byte
	var err error

	switch strings.ToLower(format) {
	case "yaml", "yml":
		data, err = yaml.Marshal(template)
		if err != nil {
			return "", fmt.Errorf("failed to generate YAML template: %w", err)
		}
	case "json":
		data, err = json.MarshalIndent(template, "", "  ")
		if err != nil {
			return "", fmt.Errorf("failed to generate JSON template: %w", err)
		}
	default:
		return "", fmt.Errorf("unsupported format: %s", format)
	}

	return string(data), nil
}

// WriteTemplate writes a configuration template to a file
func (p *Parser) WriteTemplate(path string, format string) error {
	// Generate template content
	content, err := p.GenerateTemplate(format)
	if err != nil {
		return err
	}

	// Check if file already exists
	if _, err := os.Stat(path); err == nil {
		return fmt.Errorf("file already exists: %s (use --force to overwrite)", path)
	}

	// Create directory if needed
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0750); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Write file
	if err := os.WriteFile(path, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write template file: %w", err)
	}

	return nil
}

// WriteTemplateForce writes a configuration template to a file, overwriting if it exists
func (p *Parser) WriteTemplateForce(path string, format string) error {
	// Generate template content
	content, err := p.GenerateTemplate(format)
	if err != nil {
		return err
	}

	// Create directory if needed
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0750); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Write file
	if err := os.WriteFile(path, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write template file: %w", err)
	}

	return nil
}

// ValidateFormat validates that a file has a supported format
func (p *Parser) ValidateFormat(path string) error {
	format := p.detectFormat(path)
	if format == "" {
		return fmt.Errorf("unsupported file format: %s (supported: %s)",
			filepath.Ext(path), strings.Join(p.SupportedFormats, ", "))
	}
	return nil
}

// ParseError represents a configuration parsing error
type ParseError struct {
	Path    string
	Line    int
	Column  int
	Message string
	Cause   error
}

func (e *ParseError) Error() string {
	if e.Line > 0 && e.Column > 0 {
		return fmt.Sprintf("parse error in %s at line %d, column %d: %s",
			e.Path, e.Line, e.Column, e.Message)
	}
	if e.Path != "" {
		return fmt.Sprintf("parse error in %s: %s", e.Path, e.Message)
	}
	return fmt.Sprintf("parse error: %s", e.Message)
}

// ParseFileWithValidation parses and validates a configuration file
func (p *Parser) ParseFileWithValidation(path string, validator *Validator) (*models.ProjectConfig, error) {
	// Parse the file
	config, err := p.ParseFile(path)
	if err != nil {
		return nil, err
	}

	// Validate the configuration
	if err := validator.ValidateAndApplyDefaults(config); err != nil {
		return nil, fmt.Errorf("configuration validation failed: %w", err)
	}

	return config, nil
}

// ParseWithValidation parses and validates configuration from a reader
func (p *Parser) ParseWithValidation(reader io.Reader, format string, validator *Validator) (*models.ProjectConfig, error) {
	// Parse the configuration
	config, err := p.Parse(reader, format)
	if err != nil {
		return nil, err
	}

	// Validate the configuration
	if err := validator.ValidateAndApplyDefaults(config); err != nil {
		return nil, fmt.Errorf("configuration validation failed: %w", err)
	}

	return config, nil
}
