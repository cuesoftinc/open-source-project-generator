#!/bin/bash

# {{.Name}} - Terraform Setup Script
# This script sets up the Terraform environment and prerequisites

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
PROJECT_NAME="{{.Name}}"
ORGANIZATION="{{.Organization}}"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TERRAFORM_DIR="$(dirname "$SCRIPT_DIR")"

# Functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Install Terraform
install_terraform() {
    log_info "Installing Terraform..."
    
    local os=$(uname -s | tr '[:upper:]' '[:lower:]')
    local arch=$(uname -m)
    
    case ${arch} in
        x86_64)
            arch="amd64"
            ;;
        arm64|aarch64)
            arch="arm64"
            ;;
        *)
            log_error "Unsupported architecture: ${arch}"
            exit 1
            ;;
    esac
    
    local terraform_version="1.6.6"
    local download_url="https://releases.hashicorp.com/terraform/${terraform_version}/terraform_${terraform_version}_${os}_${arch}.zip"
    local temp_dir=$(mktemp -d)
    
    log_info "Downloading Terraform ${terraform_version} for ${os}/${arch}..."
    curl -sSL "${download_url}" -o "${temp_dir}/terraform.zip"
    
    log_info "Installing Terraform..."
    unzip -q "${temp_dir}/terraform.zip" -d "${temp_dir}"
    
    # Install to /usr/local/bin if we have permission, otherwise to ~/bin
    if [ -w "/usr/local/bin" ]; then
        sudo mv "${temp_dir}/terraform" /usr/local/bin/
    else
        mkdir -p ~/bin
        mv "${temp_dir}/terraform" ~/bin/
        export PATH="$HOME/bin:$PATH"
        echo 'export PATH="$HOME/bin:$PATH"' >> ~/.bashrc
    fi
    
    rm -rf "${temp_dir}"
    
    log_success "Terraform installed successfully"
}

# Install AWS CLI
install_aws_cli() {
    log_info "Installing AWS CLI..."
    
    local os=$(uname -s | tr '[:upper:]' '[:lower:]')
    local arch=$(uname -m)
    
    case ${os} in
        linux)
            case ${arch} in
                x86_64)
                    curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                    ;;
                aarch64)
                    curl "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "awscliv2.zip"
                    ;;
                *)
                    log_error "Unsupported architecture for AWS CLI: ${arch}"
                    return 1
                    ;;
            esac
            unzip awscliv2.zip
            sudo ./aws/install
            rm -rf aws awscliv2.zip
            ;;
        darwin)
            curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"
            sudo installer -pkg AWSCLIV2.pkg -target /
            rm AWSCLIV2.pkg
            ;;
        *)
            log_error "Unsupported OS for AWS CLI installation: ${os}"
            return 1
            ;;
    esac
    
    log_success "AWS CLI installed successfully"
}

# Install kubectl
install_kubectl() {
    log_info "Installing kubectl..."
    
    local os=$(uname -s | tr '[:upper:]' '[:lower:]')
    local arch=$(uname -m)
    
    case ${arch} in
        x86_64)
            arch="amd64"
            ;;
        arm64|aarch64)
            arch="arm64"
            ;;
        *)
            log_error "Unsupported architecture: ${arch}"
            return 1
            ;;
    esac
    
    local kubectl_version=$(curl -L -s https://dl.k8s.io/release/stable.txt)
    local download_url="https://dl.k8s.io/release/${kubectl_version}/bin/${os}/${arch}/kubectl"
    
    log_info "Downloading kubectl ${kubectl_version}..."
    curl -LO "${download_url}"
    chmod +x kubectl
    
    # Install to /usr/local/bin if we have permission, otherwise to ~/bin
    if [ -w "/usr/local/bin" ]; then
        sudo mv kubectl /usr/local/bin/
    else
        mkdir -p ~/bin
        mv kubectl ~/bin/
        export PATH="$HOME/bin:$PATH"
    fi
    
    log_success "kubectl installed successfully"
}

# Install Helm
install_helm() {
    log_info "Installing Helm..."
    
    curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
    
    log_success "Helm installed successfully"
}

# Install jq
install_jq() {
    log_info "Installing jq..."
    
    local os=$(uname -s | tr '[:upper:]' '[:lower:]')
    local arch=$(uname -m)
    
    case ${os} in
        linux)
            case ${arch} in
                x86_64)
                    curl -L "https://github.com/stedolan/jq/releases/latest/download/jq-linux64" -o jq
                    ;;
                *)
                    log_warning "Installing jq via package manager..."
                    if command_exists apt-get; then
                        sudo apt-get update && sudo apt-get install -y jq
                    elif command_exists yum; then
                        sudo yum install -y jq
                    else
                        log_error "Cannot install jq automatically"
                        return 1
                    fi
                    return 0
                    ;;
            esac
            ;;
        darwin)
            curl -L "https://github.com/stedolan/jq/releases/latest/download/jq-osx-amd64" -o jq
            ;;
        *)
            log_error "Unsupported OS for jq installation: ${os}"
            return 1
            ;;
    esac
    
    chmod +x jq
    
    # Install to /usr/local/bin if we have permission, otherwise to ~/bin
    if [ -w "/usr/local/bin" ]; then
        sudo mv jq /usr/local/bin/
    else
        mkdir -p ~/bin
        mv jq ~/bin/
        export PATH="$HOME/bin:$PATH"
    fi
    
    log_success "jq installed successfully"
}

# Setup Terraform backend
setup_terraform_backend() {
    log_info "Setting up Terraform backend..."
    
    local backend_dir="${TERRAFORM_DIR}/backends"
    mkdir -p "${backend_dir}"
    
    # Create backend configuration for each environment
    for env in development staging production; do
        local backend_file="${backend_dir}/${env}.hcl"
        
        if [ ! -f "${backend_file}" ]; then
            log_info "Creating backend configuration for ${env}..."
            
            cat > "${backend_file}" << EOF
# Terraform backend configuration for ${env} environment
bucket         = "${PROJECT_NAME}-terraform-state-${env}"
key            = "infrastructure/terraform.tfstate"
region         = "us-west-2"
dynamodb_table = "${PROJECT_NAME}-terraform-locks-${env}"
encrypt        = true

# Optional: Enable versioning and lifecycle
# versioning = true
# lifecycle_rule {
#   enabled = true
#   expiration {
#     days = 90
#   }
# }
EOF
        fi
    done
    
    log_success "Terraform backend configuration created"
}

# Create AWS resources for Terraform backend
create_aws_backend_resources() {
    log_info "Creating AWS resources for Terraform backend..."
    
    if ! command_exists aws; then
        log_error "AWS CLI is required to create backend resources"
        return 1
    fi
    
    # Check AWS credentials
    if ! aws sts get-caller-identity >/dev/null 2>&1; then
        log_error "AWS credentials not configured. Run 'aws configure' first."
        return 1
    fi
    
    local region="us-west-2"
    
    for env in development staging production; do
        local bucket_name="${PROJECT_NAME}-terraform-state-${env}"
        local table_name="${PROJECT_NAME}-terraform-locks-${env}"
        
        log_info "Creating S3 bucket: ${bucket_name}"
        
        # Create S3 bucket
        if aws s3api head-bucket --bucket "${bucket_name}" 2>/dev/null; then
            log_warning "S3 bucket ${bucket_name} already exists"
        else
            aws s3api create-bucket \
                --bucket "${bucket_name}" \
                --region "${region}" \
                --create-bucket-configuration LocationConstraint="${region}"
            
            # Enable versioning
            aws s3api put-bucket-versioning \
                --bucket "${bucket_name}" \
                --versioning-configuration Status=Enabled
            
            # Enable encryption
            aws s3api put-bucket-encryption \
                --bucket "${bucket_name}" \
                --server-side-encryption-configuration '{
                    "Rules": [
                        {
                            "ApplyServerSideEncryptionByDefault": {
                                "SSEAlgorithm": "AES256"
                            }
                        }
                    ]
                }'
            
            # Block public access
            aws s3api put-public-access-block \
                --bucket "${bucket_name}" \
                --public-access-block-configuration \
                BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true
        fi
        
        log_info "Creating DynamoDB table: ${table_name}"
        
        # Create DynamoDB table for state locking
        if aws dynamodb describe-table --table-name "${table_name}" >/dev/null 2>&1; then
            log_warning "DynamoDB table ${table_name} already exists"
        else
            aws dynamodb create-table \
                --table-name "${table_name}" \
                --attribute-definitions AttributeName=LockID,AttributeType=S \
                --key-schema AttributeName=LockID,KeyType=HASH \
                --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
                --region "${region}"
            
            # Wait for table to be created
            aws dynamodb wait table-exists --table-name "${table_name}" --region "${region}"
        fi
    done
    
    log_success "AWS backend resources created successfully"
}

# Setup pre-commit hooks
setup_pre_commit_hooks() {
    log_info "Setting up pre-commit hooks..."
    
    local hooks_dir="${TERRAFORM_DIR}/.git/hooks"
    mkdir -p "${hooks_dir}"
    
    # Create pre-commit hook
    cat > "${hooks_dir}/pre-commit" << 'EOF'
#!/bin/bash

# Terraform pre-commit hook
set -e

echo "Running Terraform pre-commit checks..."

# Format Terraform files
terraform fmt -recursive

# Validate Terraform configuration
terraform validate

# Run security checks if tfsec is available
if command -v tfsec >/dev/null 2>&1; then
    echo "Running security checks..."
    tfsec .
fi

# Run linting if tflint is available
if command -v tflint >/dev/null 2>&1; then
    echo "Running Terraform linting..."
    tflint
fi

echo "Pre-commit checks completed successfully"
EOF
    
    chmod +x "${hooks_dir}/pre-commit"
    
    log_success "Pre-commit hooks setup completed"
}

# Create directory structure
create_directory_structure() {
    log_info "Creating directory structure..."
    
    local dirs=(
        "${TERRAFORM_DIR}/modules/aws"
        "${TERRAFORM_DIR}/modules/gcp"
        "${TERRAFORM_DIR}/modules/azure"
        "${TERRAFORM_DIR}/modules/kubernetes"
        "${TERRAFORM_DIR}/backends"
        "${TERRAFORM_DIR}/plans"
        "${TERRAFORM_DIR}/scripts"
    )
    
    for dir in "${dirs[@]}"; do
        mkdir -p "${dir}"
    done
    
    log_success "Directory structure created"
}

# Create .gitignore
create_gitignore() {
    log_info "Creating .gitignore..."
    
    cat > "${TERRAFORM_DIR}/.gitignore" << 'EOF'
# Terraform files
*.tfstate
*.tfstate.*
*.tfplan
*.tfvars.backup
.terraform/
.terraform.lock.hcl
crash.log
crash.*.log

# Sensitive files
*.pem
*.key
*.crt
secrets/
.env
.env.*

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Backup files
*.backup
*.bak
EOF
    
    log_success ".gitignore created"
}

# Main setup function
main() {
    log_info "Setting up Terraform environment for ${PROJECT_NAME}..."
    
    # Create directory structure
    create_directory_structure
    
    # Create .gitignore
    create_gitignore
    
    # Check and install prerequisites
    if ! command_exists terraform; then
        install_terraform
    else
        log_success "Terraform is already installed"
    fi
    
    if ! command_exists aws; then
        read -p "Install AWS CLI? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            install_aws_cli
        fi
    else
        log_success "AWS CLI is already installed"
    fi
    
    if ! command_exists kubectl; then
        read -p "Install kubectl? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            install_kubectl
        fi
    else
        log_success "kubectl is already installed"
    fi
    
    if ! command_exists helm; then
        read -p "Install Helm? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            install_helm
        fi
    else
        log_success "Helm is already installed"
    fi
    
    if ! command_exists jq; then
        install_jq
    else
        log_success "jq is already installed"
    fi
    
    # Setup Terraform backend
    setup_terraform_backend
    
    # Create AWS backend resources if AWS CLI is available
    if command_exists aws; then
        read -p "Create AWS backend resources? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            create_aws_backend_resources
        fi
    fi
    
    # Setup pre-commit hooks
    setup_pre_commit_hooks
    
    log_success "Terraform environment setup completed!"
    log_info "Next steps:"
    echo "  1. Configure your cloud provider credentials"
    echo "  2. Review and customize the environment-specific .tfvars files"
    echo "  3. Run './scripts/deploy.sh development init' to initialize Terraform"
    echo "  4. Run './scripts/deploy.sh development plan' to create a deployment plan"
    echo "  5. Run './scripts/deploy.sh development apply' to deploy the infrastructure"
}

# Script execution
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi