#!/bin/bash

# {{.Name}} - Test Script
# This script runs all tests for the project

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
PROJECT_NAME="{{.Name}}"
TEST_MODE="${TEST_MODE:-all}"
COVERAGE_ENABLED="${COVERAGE_ENABLED:-true}"
PARALLEL_TESTS="${PARALLEL_TESTS:-true}"
WATCH_MODE="${WATCH_MODE:-false}"

# Directories
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
COVERAGE_DIR="$PROJECT_ROOT/coverage"
REPORTS_DIR="$PROJECT_ROOT/test-reports"

{{if .Components.Frontend.NextJS.App}}FRONTEND_DIRS=("App"{{if .Components.Frontend.NextJS.Home}} "Home"{{end}}{{if .Components.Frontend.NextJS.Admin}} "Admin"{{end}}){{end}}
{{if .Components.Backend.GoGin}}BACKEND_DIR="CommonServer"{{end}}

# Test configuration
TEST_TIMEOUT="${TEST_TIMEOUT:-300s}"
INTEGRATION_TEST_DB="${INTEGRATION_TEST_DB:-{{.Name}}_test}"

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_step() {
    echo -e "${CYAN}[STEP]${NC} $1"
}

# Error handling
handle_error() {
    log_error "Tests failed at line $1"
    cleanup_on_error
    exit 1
}

trap 'handle_error $LINENO' ERR

# Cleanup function
cleanup_on_error() {
    log_warning "Cleaning up after test failure..."
    
    # Kill any background processes
    jobs -p | xargs -r kill 2>/dev/null || true
    
    # Stop test databases
    stop_test_services
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Setup test environment
setup_test_environment() {
    log_step "Setting up test environment..."
    
    cd "$PROJECT_ROOT"
    
    # Create test directories
    mkdir -p "$COVERAGE_DIR"
    mkdir -p "$REPORTS_DIR"
    
    # Clean previous test results if requested
    if [[ "${CLEAN_TESTS:-false}" == "true" ]]; then
        log_info "Cleaning previous test results..."
        rm -rf "$COVERAGE_DIR"/*
        rm -rf "$REPORTS_DIR"/*
    fi
    
    log_success "Test environment ready"
}

# Start test services
start_test_services() {
    log_step "Starting test services..."
    
{{if .Components.Infrastructure.Docker}}    # Check if Docker is available
    if command_exists docker && docker info >/dev/null 2>&1; then
        log_info "Starting test database with Docker..."
        
        # Create test docker-compose if it doesn't exist
        if [[ ! -f docker-compose.test.yml ]]; then
            log_info "Creating test docker-compose configuration..."
            cat > docker-compose.test.yml << EOF
version: '3.8'

services:
  postgres-test:
    image: postgres:15
    environment:
      POSTGRES_DB: $INTEGRATION_TEST_DB
      POSTGRES_USER: {{.Name}}_user
      POSTGRES_PASSWORD: password
    ports:
      - "5433:5432"
    tmpfs:
      - /var/lib/postgresql/data

  redis-test:
    image: redis:7-alpine
    ports:
      - "6380:6379"
    tmpfs:
      - /data
EOF
        fi
        
        # Start test services
        docker-compose -f docker-compose.test.yml up -d
        
        # Wait for services to be ready
        log_info "Waiting for test services to be ready..."
        sleep 5
        
        # Test database connection
        local max_attempts=30
        local attempt=1
        
        while [[ $attempt -le $max_attempts ]]; do
            if psql "postgresql://{{.Name}}_user:password@localhost:5433/$INTEGRATION_TEST_DB" -c '\q' 2>/dev/null; then
                log_success "Test database is ready"
                break
            fi
            
            if [[ $attempt -eq $max_attempts ]]; then
                log_error "Test database failed to start"
                exit 1
            fi
            
            log_info "Waiting for test database... (attempt $attempt/$max_attempts)"
            sleep 2
            ((attempt++))
        done
        
    else
        log_warning "Docker not available, using local test services"
    fi{{else}}    log_info "Using local test services"{{end}}
    
    log_success "Test services started"
}

# Stop test services
stop_test_services() {
    log_info "Stopping test services..."
    
{{if .Components.Infrastructure.Docker}}    if [[ -f docker-compose.test.yml ]]; then
        docker-compose -f docker-compose.test.yml down -v 2>/dev/null || true
    fi{{end}}
    
    log_success "Test services stopped"
}

{{if .Components.Frontend.NextJS.App}}# Run frontend tests
run_frontend_tests() {
    log_step "Running frontend tests..."
    
    local test_results=()
    local pids=()
    
    for dir in "${FRONTEND_DIRS[@]}"; do
        if [[ -d "$dir" ]]; then
            log_info "Running tests for $dir..."
            
            if [[ "$PARALLEL_TESTS" == "true" && "$WATCH_MODE" == "false" ]]; then
                # Run tests in parallel
                (
                    cd "$dir"
                    
                    # Set test environment
                    export NODE_ENV=test
                    export CI=true
                    
                    # Install dependencies if needed
                    if [[ ! -d node_modules ]]; then
                        log_info "Installing dependencies for $dir..."
                        npm ci
                    fi
                    
                    # Create coverage directory
                    mkdir -p "$COVERAGE_DIR/$dir"
                    
                    # Run tests based on mode
                    case "$TEST_MODE" in
                        unit)
                            if [[ "$COVERAGE_ENABLED" == "true" ]]; then
                                npm run test:coverage -- --reporter=verbose --outputFile="$REPORTS_DIR/$dir-unit.json"
                            else
                                npm test -- --run --reporter=verbose
                            fi
                            ;;
                        integration)
                            if npm run | grep -q "test:integration"; then
                                npm run test:integration -- --reporter=verbose
                            else
                                log_warning "$dir: No integration tests found"
                            fi
                            ;;
                        e2e)
                            if npm run | grep -q "test:e2e"; then
                                npm run test:e2e -- --reporter=verbose
                            else
                                log_warning "$dir: No e2e tests found"
                            fi
                            ;;
                        *)
                            if [[ "$COVERAGE_ENABLED" == "true" ]]; then
                                npm run test:coverage -- --reporter=verbose --outputFile="$REPORTS_DIR/$dir-all.json"
                            else
                                npm test -- --run --reporter=verbose
                            fi
                            ;;
                    esac
                    
                    # Copy coverage reports
                    if [[ "$COVERAGE_ENABLED" == "true" && -d coverage ]]; then
                        cp -r coverage/* "$COVERAGE_DIR/$dir/" 2>/dev/null || true
                    fi
                    
                    echo "$dir:SUCCESS" > "/tmp/test-result-$dir"
                ) &
                pids+=($!)
            else
                # Run tests sequentially or in watch mode
                cd "$dir"
                
                export NODE_ENV=test
                export CI=true
                
                if [[ ! -d node_modules ]]; then
                    log_info "Installing dependencies for $dir..."
                    npm ci
                fi
                
                mkdir -p "$COVERAGE_DIR/$dir"
                
                if [[ "$WATCH_MODE" == "true" ]]; then
                    log_info "Running $dir tests in watch mode..."
                    npm test
                else
                    case "$TEST_MODE" in
                        unit)
                            if [[ "$COVERAGE_ENABLED" == "true" ]]; then
                                npm run test:coverage -- --reporter=verbose --outputFile="$REPORTS_DIR/$dir-unit.json"
                            else
                                npm test -- --run --reporter=verbose
                            fi
                            ;;
                        integration)
                            if npm run | grep -q "test:integration"; then
                                npm run test:integration -- --reporter=verbose
                            else
                                log_warning "$dir: No integration tests found"
                            fi
                            ;;
                        e2e)
                            if npm run | grep -q "test:e2e"; then
                                npm run test:e2e -- --reporter=verbose
                            else
                                log_warning "$dir: No e2e tests found"
                            fi
                            ;;
                        *)
                            if [[ "$COVERAGE_ENABLED" == "true" ]]; then
                                npm run test:coverage -- --reporter=verbose --outputFile="$REPORTS_DIR/$dir-all.json"
                            else
                                npm test -- --run --reporter=verbose
                            fi
                            ;;
                    esac
                    
                    if [[ "$COVERAGE_ENABLED" == "true" && -d coverage ]]; then
                        cp -r coverage/* "$COVERAGE_DIR/$dir/" 2>/dev/null || true
                    fi
                fi
                
                cd "$PROJECT_ROOT"
                log_success "$dir tests completed"
            fi
        else
            log_warning "$dir directory not found"
        fi
    done
    
    # Wait for parallel tests to complete
    if [[ "$PARALLEL_TESTS" == "true" && "$WATCH_MODE" == "false" && ${#pids[@]} -gt 0 ]]; then
        log_info "Waiting for parallel frontend tests to complete..."
        
        for pid in "${pids[@]}"; do
            wait "$pid"
        done
        
        # Check results
        for dir in "${FRONTEND_DIRS[@]}"; do
            if [[ -f "/tmp/test-result-$dir" ]]; then
                local result=$(cat "/tmp/test-result-$dir")
                if [[ "$result" == "$dir:SUCCESS" ]]; then
                    log_success "$dir tests completed"
                else
                    log_error "$dir tests failed"
                    exit 1
                fi
                rm -f "/tmp/test-result-$dir"
            fi
        done
    fi
    
    log_success "Frontend tests completed"
}{{end}}

{{if .Components.Backend.GoGin}}# Run backend tests
run_backend_tests() {
    log_step "Running backend tests..."
    
    if [[ ! -d "$BACKEND_DIR" ]]; then
        log_warning "Backend directory not found"
        return 0
    fi
    
    cd "$BACKEND_DIR"
    
    # Set test environment variables
    export GO_ENV=test
    export DATABASE_URL="postgresql://{{.Name}}_user:password@localhost:5433/$INTEGRATION_TEST_DB"
    export REDIS_URL="redis://localhost:6380/0"
    
    # Create coverage directory
    mkdir -p "$COVERAGE_DIR/backend"
    
    case "$TEST_MODE" in
        unit)
            log_info "Running backend unit tests..."
            if [[ "$COVERAGE_ENABLED" == "true" ]]; then
                go test -v -short -coverprofile="$COVERAGE_DIR/backend/coverage.out" ./...
                go tool cover -html="$COVERAGE_DIR/backend/coverage.out" -o "$COVERAGE_DIR/backend/coverage.html"
                go tool cover -func="$COVERAGE_DIR/backend/coverage.out" > "$COVERAGE_DIR/backend/coverage.txt"
            else
                go test -v -short ./...
            fi
            ;;
        integration)
            log_info "Running backend integration tests..."
            
            # Run database migrations for tests
            if [[ -f "cmd/migrate/main.go" ]]; then
                log_info "Running test database migrations..."
                go run cmd/migrate/main.go up
            fi
            
            if [[ "$COVERAGE_ENABLED" == "true" ]]; then
                go test -v -tags=integration -coverprofile="$COVERAGE_DIR/backend/integration-coverage.out" ./...
                go tool cover -html="$COVERAGE_DIR/backend/integration-coverage.out" -o "$COVERAGE_DIR/backend/integration-coverage.html"
            else
                go test -v -tags=integration ./...
            fi
            ;;
        benchmark)
            log_info "Running backend benchmark tests..."
            go test -v -bench=. -benchmem ./... | tee "$REPORTS_DIR/backend-benchmark.txt"
            ;;
        race)
            log_info "Running backend tests with race detection..."
            go test -v -race ./...
            ;;
        *)
            log_info "Running all backend tests..."
            
            # Run migrations first
            if [[ -f "cmd/migrate/main.go" ]]; then
                log_info "Running test database migrations..."
                go run cmd/migrate/main.go up
            fi
            
            if [[ "$COVERAGE_ENABLED" == "true" ]]; then
                # Run unit tests
                go test -v -short -coverprofile="$COVERAGE_DIR/backend/unit-coverage.out" ./...
                
                # Run integration tests
                go test -v -tags=integration -coverprofile="$COVERAGE_DIR/backend/integration-coverage.out" ./...
                
                # Merge coverage reports
                if command_exists gocovmerge; then
                    gocovmerge "$COVERAGE_DIR/backend/unit-coverage.out" "$COVERAGE_DIR/backend/integration-coverage.out" > "$COVERAGE_DIR/backend/coverage.out"
                else
                    log_warning "gocovmerge not found, using unit test coverage only"
                    cp "$COVERAGE_DIR/backend/unit-coverage.out" "$COVERAGE_DIR/backend/coverage.out"
                fi
                
                # Generate HTML report
                go tool cover -html="$COVERAGE_DIR/backend/coverage.out" -o "$COVERAGE_DIR/backend/coverage.html"
                go tool cover -func="$COVERAGE_DIR/backend/coverage.out" > "$COVERAGE_DIR/backend/coverage.txt"
                
                # Show coverage summary
                local coverage_percent=$(go tool cover -func="$COVERAGE_DIR/backend/coverage.out" | grep total | awk '{print $3}')
                log_info "Backend test coverage: $coverage_percent"
            else
                go test -v ./...
                go test -v -tags=integration ./...
            fi
            ;;
    esac
    
    cd "$PROJECT_ROOT"
    log_success "Backend tests completed"
}{{end}}

# Run security tests
run_security_tests() {
    if [[ "$TEST_MODE" != "all" && "$TEST_MODE" != "security" ]]; then
        return 0
    fi
    
    log_step "Running security tests..."
    
{{if .Components.Frontend.NextJS.App}}    # Frontend security audit
    for dir in "${FRONTEND_DIRS[@]}"; do
        if [[ -d "$dir" ]]; then
            log_info "Running security audit for $dir..."
            cd "$dir"
            
            # npm audit
            if npm audit --audit-level=moderate; then
                log_success "$dir security audit passed"
            else
                log_warning "$dir has security vulnerabilities"
            fi
            
            cd "$PROJECT_ROOT"
        fi
    done{{end}}
    
{{if .Components.Backend.GoGin}}    # Backend security scan
    if [[ -d "$BACKEND_DIR" ]]; then
        log_info "Running backend security scan..."
        cd "$BACKEND_DIR"
        
        # gosec security scanner
        if command_exists gosec; then
            gosec -fmt json -out "$REPORTS_DIR/backend-security.json" ./...
            log_success "Backend security scan completed"
        else
            log_warning "gosec not found, installing..."
            go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest
            gosec -fmt json -out "$REPORTS_DIR/backend-security.json" ./...
        fi
        
        cd "$PROJECT_ROOT"
    fi{{end}}
    
    log_success "Security tests completed"
}

# Generate test reports
generate_test_reports() {
    log_step "Generating test reports..."
    
    local report_file="$REPORTS_DIR/test-summary.md"
    
    cat > "$report_file" << EOF
# {{.Name}} Test Report

**Test Date:** $(date -u +"%Y-%m-%dT%H:%M:%SZ")  
**Test Mode:** $TEST_MODE  
**Coverage Enabled:** $COVERAGE_ENABLED  

## Test Results

EOF

{{if .Components.Frontend.NextJS.App}}    echo "### Frontend Tests" >> "$report_file"
    echo "" >> "$report_file"
    
    for dir in "${FRONTEND_DIRS[@]}"; do
        if [[ -d "$dir" ]]; then
            echo "#### $dir" >> "$report_file"
            
            if [[ -f "$COVERAGE_DIR/$dir/coverage.txt" ]]; then
                echo "**Coverage:**" >> "$report_file"
                echo "\`\`\`" >> "$report_file"
                cat "$COVERAGE_DIR/$dir/coverage.txt" >> "$report_file"
                echo "\`\`\`" >> "$report_file"
            fi
            
            if [[ -f "$REPORTS_DIR/$dir-all.json" ]]; then
                echo "**Test Results:** See $dir-all.json" >> "$report_file"
            fi
            
            echo "" >> "$report_file"
        fi
    done{{end}}

{{if .Components.Backend.GoGin}}    echo "### Backend Tests" >> "$report_file"
    echo "" >> "$report_file"
    
    if [[ -f "$COVERAGE_DIR/backend/coverage.txt" ]]; then
        echo "**Coverage:**" >> "$report_file"
        echo "\`\`\`" >> "$report_file"
        cat "$COVERAGE_DIR/backend/coverage.txt" >> "$report_file"
        echo "\`\`\`" >> "$report_file"
    fi
    
    if [[ -f "$REPORTS_DIR/backend-benchmark.txt" ]]; then
        echo "**Benchmark Results:**" >> "$report_file"
        echo "\`\`\`" >> "$report_file"
        tail -20 "$REPORTS_DIR/backend-benchmark.txt" >> "$report_file"
        echo "\`\`\`" >> "$report_file"
    fi
    
    echo "" >> "$report_file"{{end}}

    echo "## Coverage Reports" >> "$report_file"
    echo "" >> "$report_file"
    
    if [[ -d "$COVERAGE_DIR" ]]; then
        find "$COVERAGE_DIR" -name "*.html" | while read -r file; do
            local relative_path=$(realpath --relative-to="$PROJECT_ROOT" "$file")
            echo "- [$relative_path]($relative_path)" >> "$report_file"
        done
    fi
    
    log_success "Test report generated: $report_file"
}

# Show test summary
show_test_summary() {
    log_success "Tests completed successfully!"
    echo ""
    echo -e "${CYAN}Test Summary:${NC}"
    echo "  Test Mode: $TEST_MODE"
    echo "  Coverage Enabled: $COVERAGE_ENABLED"
    echo "  Parallel Tests: $PARALLEL_TESTS"
    echo ""
    
    if [[ "$COVERAGE_ENABLED" == "true" ]]; then
        echo -e "${CYAN}Coverage Reports:${NC}"
        
{{if .Components.Frontend.NextJS.App}}        for dir in "${FRONTEND_DIRS[@]}"; do
            if [[ -f "$COVERAGE_DIR/$dir/coverage.html" ]]; then
                echo "  Frontend ($dir): file://$COVERAGE_DIR/$dir/coverage.html"
            fi
        done{{end}}
        
{{if .Components.Backend.GoGin}}        if [[ -f "$COVERAGE_DIR/backend/coverage.html" ]]; then
            echo "  Backend: file://$COVERAGE_DIR/backend/coverage.html"
        fi{{end}}
        
        echo ""
    fi
    
    echo -e "${CYAN}Test Reports:${NC}"
    echo "  Summary: $REPORTS_DIR/test-summary.md"
    
    if [[ -d "$REPORTS_DIR" ]]; then
        find "$REPORTS_DIR" -name "*.json" -o -name "*.txt" | while read -r file; do
            echo "  $(basename "$file"): $file"
        done
    fi
    
    echo ""
    echo -e "${GREEN}All tests completed successfully! ✅${NC}"
}

# Main test function
main() {
    echo -e "${CYAN}"
    echo "╔══════════════════════════════════════════════════════════════╗"
    echo "║                     {{.Name}} Test Script                      ║"
    echo "║                 Running comprehensive tests                  ║"
    echo "╚══════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    
    setup_test_environment
    
    if [[ "$WATCH_MODE" == "false" ]]; then
        start_test_services
    fi
    
{{if .Components.Frontend.NextJS.App}}    if [[ "$TEST_MODE" == "all" || "$TEST_MODE" == "frontend" || "$TEST_MODE" == "unit" || "$TEST_MODE" == "integration" || "$TEST_MODE" == "e2e" ]]; then
        run_frontend_tests
    fi{{end}}
    
{{if .Components.Backend.GoGin}}    if [[ "$TEST_MODE" == "all" || "$TEST_MODE" == "backend" || "$TEST_MODE" == "unit" || "$TEST_MODE" == "integration" || "$TEST_MODE" == "benchmark" || "$TEST_MODE" == "race" ]]; then
        run_backend_tests
    fi{{end}}
    
    if [[ "$WATCH_MODE" == "false" ]]; then
        run_security_tests
        generate_test_reports
        stop_test_services
        show_test_summary
    fi
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --mode)
            TEST_MODE="$2"
            shift 2
            ;;
        --no-coverage)
            COVERAGE_ENABLED=false
            shift
            ;;
        --sequential)
            PARALLEL_TESTS=false
            shift
            ;;
        --watch)
            WATCH_MODE=true
            shift
            ;;
        --clean)
            CLEAN_TESTS=true
            shift
            ;;
        --timeout)
            TEST_TIMEOUT="$2"
            shift 2
            ;;
        --help|-h)
            echo "{{.Name}} Test Script"
            echo ""
            echo "Usage: $0 [options]"
            echo ""
            echo "Options:"
            echo "  --mode MODE           Test mode (all|frontend|backend|unit|integration|e2e|benchmark|race|security)"
            echo "  --no-coverage         Disable coverage reporting"
            echo "  --sequential          Run tests sequentially"
            echo "  --watch               Run tests in watch mode"
            echo "  --clean               Clean previous test results"
            echo "  --timeout DURATION    Test timeout (default: 300s)"
            echo "  --help, -h            Show this help message"
            echo ""
            echo "Environment Variables:"
            echo "  TEST_MODE             Test mode to run"
            echo "  COVERAGE_ENABLED      Enable coverage reporting (true|false)"
            echo "  PARALLEL_TESTS        Run tests in parallel (true|false)"
            echo "  WATCH_MODE            Run in watch mode (true|false)"
            echo "  TEST_TIMEOUT          Test timeout duration"
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Validate test mode
case "$TEST_MODE" in
    all|frontend|backend|unit|integration|e2e|benchmark|race|security)
        ;;
    *)
        log_error "Invalid test mode: $TEST_MODE"
        log_error "Valid modes: all, frontend, backend, unit, integration, e2e, benchmark, race, security"
        exit 1
        ;;
esac

# Run main test function
main