package {{.Organization}}.{{.Name | lower}}.mobile.data.repository

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import {{.Organization}}.{{.Name | lower}}.mobile.domain.repository.UserRepository
import {{.Organization}}.{{.Name | lower}}.mobile.domain.model.User
import {{.Organization}}.{{.Name | lower}}.mobile.domain.model.LoginCredentials
import {{.Organization}}.{{.Name | lower}}.mobile.domain.model.AuthToken
import {{.Organization}}.{{.Name | lower}}.mobile.data.remote.api.ApiService
import {{.Organization}}.{{.Name | lower}}.mobile.data.local.dao.UserDao
import {{.Organization}}.{{.Name | lower}}.mobile.data.mapper.UserMapper
import {{.Organization}}.{{.Name | lower}}.mobile.core.util.Resource

class UserRepositoryImpl @Inject constructor(
    private val apiService: ApiService,
    private val userDao: UserDao,
    private val userMapper: UserMapper
) : UserRepository {

    override suspend fun login(credentials: LoginCredentials): Resource<AuthToken> {
        return try {
            val response = apiService.login(userMapper.toLoginRequest(credentials))
            if (response.isSuccessful && response.body()?.success == true) {
                val loginResponse = response.body()!!.data!!
                Resource.Success(userMapper.toAuthToken(loginResponse))
            } else {
                Resource.Error(response.body()?.error ?: "Login failed")
            }
        } catch (e: Exception) {
            Resource.Error(e.message ?: "Unknown error occurred")
        }
    }

    override suspend fun getUserProfile(): Resource<User> {
        return try {
            val response = apiService.getUserProfile()
            if (response.isSuccessful && response.body()?.success == true) {
                val userDto = response.body()!!.data!!
                val user = userMapper.toUser(userDto)
                userDao.insertUser(userMapper.toUserEntity(user))
                Resource.Success(user)
            } else {
                Resource.Error(response.body()?.error ?: "Failed to get profile")
            }
        } catch (e: Exception) {
            Resource.Error(e.message ?: "Unknown error occurred")
        }
    } 
   override fun getUsers(): Flow<Resource<List<User>>> = flow {
        emit(Resource.Loading())
        
        try {
            // Emit cached data first
            userDao.getAllUsers().collect { entities ->
                val users = entities.map { userMapper.toUser(it) }
                emit(Resource.Success(users))
            }
            
            // Then fetch from network
            val response = apiService.getUsers()
            if (response.isSuccessful && response.body()?.success == true) {
                val userDtos = response.body()!!.data!!
                val users = userDtos.map { userMapper.toUser(it) }
                val entities = users.map { userMapper.toUserEntity(it) }
                userDao.insertUsers(entities)
            }
        } catch (e: Exception) {
            emit(Resource.Error(e.message ?: "Unknown error occurred"))
        }
    }

    override suspend fun getUserById(id: String): Resource<User> {
        return try {
            val response = apiService.getUserById(id)
            if (response.isSuccessful && response.body()?.success == true) {
                val userDto = response.body()!!.data!!
                val user = userMapper.toUser(userDto)
                userDao.insertUser(userMapper.toUserEntity(user))
                Resource.Success(user)
            } else {
                Resource.Error(response.body()?.error ?: "User not found")
            }
        } catch (e: Exception) {
            Resource.Error(e.message ?: "Unknown error occurred")
        }
    }

    override suspend fun updateUser(user: User): Resource<User> {
        return try {
            val userDto = userMapper.toUserDto(user)
            val response = apiService.updateUser(user.id, userDto)
            if (response.isSuccessful && response.body()?.success == true) {
                val updatedUserDto = response.body()!!.data!!
                val updatedUser = userMapper.toUser(updatedUserDto)
                userDao.updateUser(userMapper.toUserEntity(updatedUser))
                Resource.Success(updatedUser)
            } else {
                Resource.Error(response.body()?.error ?: "Failed to update user")
            }
        } catch (e: Exception) {
            Resource.Error(e.message ?: "Unknown error occurred")
        }
    }

    override suspend fun deleteUser(id: String): Resource<Unit> {
        return try {
            val response = apiService.deleteUser(id)
            if (response.isSuccessful && response.body()?.success == true) {
                userDao.deleteUserById(id)
                Resource.Success(Unit)
            } else {
                Resource.Error(response.body()?.error ?: "Failed to delete user")
            }
        } catch (e: Exception) {
            Resource.Error(e.message ?: "Unknown error occurred")
        }
    }

    override suspend fun syncUsers(): Resource<Unit> {
        return try {
            val response = apiService.getUsers()
            if (response.isSuccessful && response.body()?.success == true) {
                val userDtos = response.body()!!.data!!
                val users = userDtos.map { userMapper.toUser(it) }
                val entities = users.map { userMapper.toUserEntity(it) }
                userDao.deleteAllUsers()
                userDao.insertUsers(entities)
                Resource.Success(Unit)
            } else {
                Resource.Error(response.body()?.error ?: "Failed to sync users")
            }
        } catch (e: Exception) {
            Resource.Error(e.message ?: "Unknown error occurred")
        }
    }

    override fun getCachedUsers(): Flow<List<User>> {
        return userDao.getAllUsers().map { entities ->
            entities.map { userMapper.toUser(it) }
        }
    }
}