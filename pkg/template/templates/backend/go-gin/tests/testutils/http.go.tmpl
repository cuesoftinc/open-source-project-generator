package testutils

import (
	"bytes"
	"encoding/json"
	"io"
	"net/http"
	"net/http/httptest"
)

// HTTPTestRequest represents a test HTTP request
type HTTPTestRequest struct {
	Method  string
	URL     string
	Body    interface{}
	Headers map[string]string
}

// HTTPTestResponse represents a test HTTP response
type HTTPTestResponse struct {
	StatusCode int
	Body       []byte
	Headers    http.Header
}

// MakeRequest creates and executes an HTTP test request
func MakeRequest(handler http.Handler, req HTTPTestRequest) *HTTPTestResponse {
	var body io.Reader
	if req.Body != nil {
		jsonBody, _ := json.Marshal(req.Body)
		body = bytes.NewBuffer(jsonBody)
	}

	httpReq := httptest.NewRequest(req.Method, req.URL, body)
	
	// Set default content type for POST/PUT requests
	if req.Body != nil && (req.Method == "POST" || req.Method == "PUT" || req.Method == "PATCH") {
		httpReq.Header.Set("Content-Type", "application/json")
	}

	// Set custom headers
	for key, value := range req.Headers {
		httpReq.Header.Set(key, value)
	}

	w := httptest.NewRecorder()
	handler.ServeHTTP(w, httpReq)

	return &HTTPTestResponse{
		StatusCode: w.Code,
		Body:       w.Body.Bytes(),
		Headers:    w.Header(),
	}
}

// ParseJSONResponse parses JSON response body into the provided interface
func ParseJSONResponse(response *HTTPTestResponse, v interface{}) error {
	return json.Unmarshal(response.Body, v)
}

// AssertJSONResponse asserts that the response contains expected JSON data
func AssertJSONResponse(response *HTTPTestResponse, expected interface{}) bool {
	expectedJSON, _ := json.Marshal(expected)
	return bytes.Equal(response.Body, expectedJSON)
}