package generators

import (
	"fmt"
	"path/filepath"

	"github.com/cuesoftinc/open-source-project-generator/pkg/models"
)

// TemplateGenerator handles template-based file generation
type TemplateGenerator struct {
	fsOps FileSystemOperationsInterface
}

// NewTemplateGenerator creates a new template generator
func NewTemplateGenerator(fsOps FileSystemOperationsInterface) *TemplateGenerator {
	return &TemplateGenerator{
		fsOps: fsOps,
	}
}

// GenerateRootFiles creates root-level configuration files
func (tg *TemplateGenerator) GenerateRootFiles(projectPath string, config *models.ProjectConfig) error {
	// Generate Makefile
	makefileContent := tg.generateMakefileContent(config)
	makefilePath := filepath.Join(projectPath, "Makefile")
	if err := tg.fsOps.WriteFile(makefilePath, []byte(makefileContent), 0644); err != nil {
		return fmt.Errorf("failed to create Makefile: %w", err)
	}

	// Generate README.md
	readmeContent := tg.generateReadmeContent(config)
	readmePath := filepath.Join(projectPath, "README.md")
	if err := tg.fsOps.WriteFile(readmePath, []byte(readmeContent), 0644); err != nil {
		return fmt.Errorf("failed to create README.md: %w", err)
	}

	// Generate docker-compose.yml
	dockerComposeContent := tg.generateDockerComposeContent(config)
	dockerComposePath := filepath.Join(projectPath, "docker-compose.yml")
	if err := tg.fsOps.WriteFile(dockerComposePath, []byte(dockerComposeContent), 0644); err != nil {
		return fmt.Errorf("failed to create docker-compose.yml: %w", err)
	}

	// Generate .gitignore
	gitignoreContent := tg.generateGitignoreContent(config)
	gitignorePath := filepath.Join(projectPath, ".gitignore")
	if err := tg.fsOps.WriteFile(gitignorePath, []byte(gitignoreContent), 0644); err != nil {
		return fmt.Errorf("failed to create .gitignore: %w", err)
	}

	return nil
}

// generateMakefileContent generates Makefile content
func (tg *TemplateGenerator) generateMakefileContent(config *models.ProjectConfig) string {
	return fmt.Sprintf(`# %s Makefile
# Generated by Open Source Project Generator

.PHONY: help setup dev test build clean

help: ## Show this help message
	@echo "Available commands:"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%%-20s\033[0m %%s\n", $1, $2}'

setup: ## Set up the development environment
	@echo "Setting up %s development environment..."
	@echo "Project setup complete!"

dev: ## Start development servers
	@echo "Starting development servers for %s..."

test: ## Run all tests
	@echo "Running tests for %s..."

build: ## Build all components
	@echo "Building %s..."

clean: ## Clean build artifacts
	@echo "Cleaning build artifacts for %s..."
`, config.Name, config.Name, config.Name, config.Name, config.Name, config.Name)
}

// generateReadmeContent generates README.md content
func (tg *TemplateGenerator) generateReadmeContent(config *models.ProjectConfig) string {
	return fmt.Sprintf(`# %s

%s

## Description

%s

## Getting Started

### Prerequisites

- Node.js 18+
- Go 1.22+
- Docker
- Make

### Installation

1. Clone the repository:
   `+"```bash"+`
   git clone %s
   cd %s
   `+"```"+`

2. Set up the development environment:
   `+"```bash"+`
   make setup
   `+"```"+`

3. Start the development servers:
   `+"```bash"+`
   make dev
   `+"```"+`

## Project Structure

This project follows a multi-service architecture with the following components:

- **App/**: Main frontend application
- **Home/**: Landing page application
- **Admin/**: Admin dashboard
- **CommonServer/**: Backend API server
- **Mobile/**: Mobile applications (Android & iOS)
- **Deploy/**: Infrastructure and deployment configurations
- **Tests/**: Test suites

## Development

### Running Tests

`+"```bash"+`
make test
`+"```"+`

### Building

`+"```bash"+`
make build
`+"```"+`

## License

This project is licensed under the %s License - see the [LICENSE](LICENSE) file for details.

## Contributing

Please read [CONTRIBUTING.md](CONTRIBUTING.md) for details on our code of conduct and the process for submitting pull requests.
`, config.Name, config.Organization, config.Description, "", config.Name, config.License)
}

// generateDockerComposeContent generates docker-compose.yml content
func (tg *TemplateGenerator) generateDockerComposeContent(config *models.ProjectConfig) string {
	return fmt.Sprintf(`version: '3.8'

services:
  # %s services
  # Generated by Open Source Project Generator
  
  # Add your services here based on selected components
  
networks:
  %s-network:
    driver: bridge

volumes:
  %s-data:
`, config.Name, config.Name, config.Name)
}

// generateGitignoreContent generates .gitignore content
func (tg *TemplateGenerator) generateGitignoreContent(config *models.ProjectConfig) string {
	return `# Dependencies
node_modules/
vendor/

# Build outputs
dist/
build/
*.exe
*.dll
*.so
*.dylib

# Test coverage
coverage/
*.out

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Temporary files
tmp/
temp/
`
}
