package license

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewLicenseChecker(t *testing.T) {
	checker := NewLicenseChecker()

	assert.NotNil(t, checker)
	assert.NotNil(t, checker.compatibilityMatrix)
	assert.NotNil(t, checker.riskLevels)

	// Test that default compatibility matrix is populated
	assert.Contains(t, checker.compatibilityMatrix, "MIT")
	assert.Contains(t, checker.compatibilityMatrix, "Apache-2.0")
	assert.Contains(t, checker.compatibilityMatrix, "GPL-3.0")

	// Test that default risk levels are populated
	assert.Equal(t, "high", checker.riskLevels["GPL-3.0"])
	assert.Equal(t, "low", checker.riskLevels["MIT"])
}

func TestLicenseChecker_AuditLicenses(t *testing.T) {
	checker := NewLicenseChecker()

	// Create temporary test directory
	tempDir, err := os.MkdirTemp("", "license_test")
	require.NoError(t, err)
	defer os.RemoveAll(tempDir)

	// Create a LICENSE file
	licenseContent := "MIT License\n\nCopyright (c) 2023 Test Project"
	err = os.WriteFile(filepath.Join(tempDir, "LICENSE"), []byte(licenseContent), 0644)
	require.NoError(t, err)

	// Create a simple package.json
	packageJSON := `{
		"name": "test-project",
		"dependencies": {
			"express": "^4.18.0",
			"lodash": "^4.17.21"
		}
	}`
	err = os.WriteFile(filepath.Join(tempDir, "package.json"), []byte(packageJSON), 0644)
	require.NoError(t, err)

	result, err := checker.AuditLicenses(tempDir)
	require.NoError(t, err)

	assert.NotNil(t, result)
	assert.True(t, result.Score >= 0 && result.Score <= 100)
	assert.NotEmpty(t, result.Licenses)
	// Recommendations are empty since they're generated by the engine
	assert.Empty(t, result.Recommendations)
}

func TestLicenseChecker_CheckLicenseCompatibility(t *testing.T) {
	checker := NewLicenseChecker()

	// Create temporary test directory
	tempDir, err := os.MkdirTemp("", "license_test")
	require.NoError(t, err)
	defer os.RemoveAll(tempDir)

	// Create a LICENSE file
	licenseContent := "MIT License\n\nCopyright (c) 2023 Test Project"
	err = os.WriteFile(filepath.Join(tempDir, "LICENSE"), []byte(licenseContent), 0644)
	require.NoError(t, err)

	// Create a simple go.mod
	goMod := `module test-project

go 1.19

require (
	github.com/gin-gonic/gin v1.9.0
	github.com/stretchr/testify v1.8.0
)`
	err = os.WriteFile(filepath.Join(tempDir, "go.mod"), []byte(goMod), 0644)
	require.NoError(t, err)

	result, err := checker.CheckLicenseCompatibility(tempDir)
	require.NoError(t, err)

	assert.NotNil(t, result)
	assert.Equal(t, "MIT", result.ProjectLicense)
	assert.NotEmpty(t, result.Dependencies)
	assert.Equal(t, len(result.Dependencies), result.Summary.TotalLicenses)
}

func TestLicenseChecker_ScanLicenseViolations(t *testing.T) {
	checker := NewLicenseChecker()

	// Test with directory without LICENSE file
	tempDir, err := os.MkdirTemp("", "license_test")
	require.NoError(t, err)
	defer os.RemoveAll(tempDir)

	result, err := checker.ScanLicenseViolations(tempDir)
	require.NoError(t, err)

	assert.NotNil(t, result)
	assert.Greater(t, result.Summary.TotalViolations, 0)
	assert.Greater(t, len(result.Violations), 0)

	// Check that missing license violation is detected
	found := false
	for _, violation := range result.Violations {
		if violation.Type == "missing" && violation.Dependency == "project" {
			found = true
			break
		}
	}
	assert.True(t, found, "Missing license violation should be detected")
}

func TestLicenseChecker_detectProjectLicense(t *testing.T) {
	checker := NewLicenseChecker()

	tests := []struct {
		name            string
		licenseContent  string
		expectedLicense string
		shouldError     bool
	}{
		{
			name:            "MIT License",
			licenseContent:  "MIT License\n\nCopyright (c) 2023 Test",
			expectedLicense: "MIT",
			shouldError:     false,
		},
		{
			name:            "Apache License",
			licenseContent:  "Apache License\nVersion 2.0",
			expectedLicense: "Apache-2.0",
			shouldError:     false,
		},
		{
			name:            "GPL License",
			licenseContent:  "GNU General Public License\nVersion 3",
			expectedLicense: "GPL-3.0",
			shouldError:     false,
		},
		{
			name:            "BSD License",
			licenseContent:  "BSD 3-Clause License",
			expectedLicense: "BSD-3-Clause",
			shouldError:     false,
		},
		{
			name:            "Custom License",
			licenseContent:  "Custom License Terms",
			expectedLicense: "custom",
			shouldError:     false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tempDir, err := os.MkdirTemp("", "license_test")
			require.NoError(t, err)
			defer os.RemoveAll(tempDir)

			err = os.WriteFile(filepath.Join(tempDir, "LICENSE"), []byte(tt.licenseContent), 0644)
			require.NoError(t, err)

			license, err := checker.detectProjectLicense(tempDir)

			if tt.shouldError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expectedLicense, license)
			}
		})
	}

	// Test no license file
	t.Run("No License File", func(t *testing.T) {
		tempDir, err := os.MkdirTemp("", "license_test")
		require.NoError(t, err)
		defer os.RemoveAll(tempDir)

		license, err := checker.detectProjectLicense(tempDir)
		assert.Error(t, err)
		assert.Equal(t, "unknown", license)
	})
}

func TestLicenseChecker_analyzeDependencyLicenses(t *testing.T) {
	checker := NewLicenseChecker()

	tempDir, err := os.MkdirTemp("", "license_test")
	require.NoError(t, err)
	defer os.RemoveAll(tempDir)

	// Test with package.json
	packageJSON := `{
		"name": "test-project",
		"dependencies": {
			"express": "^4.18.0",
			"lodash": "^4.17.21"
		}
	}`
	err = os.WriteFile(filepath.Join(tempDir, "package.json"), []byte(packageJSON), 0644)
	require.NoError(t, err)

	licenses, err := checker.analyzeDependencyLicenses(tempDir)
	require.NoError(t, err)

	assert.NotEmpty(t, licenses)
	assert.Len(t, licenses, 2) // express and lodash

	// Verify license structure
	for _, license := range licenses {
		assert.NotEmpty(t, license.Dependency)
		assert.NotEmpty(t, license.License)
		assert.NotEmpty(t, license.SPDXID)
		assert.NotEmpty(t, license.Risk)
	}
}

func TestLicenseChecker_analyzeNpmLicenses(t *testing.T) {
	checker := NewLicenseChecker()

	tempDir, err := os.MkdirTemp("", "license_test")
	require.NoError(t, err)
	defer os.RemoveAll(tempDir)

	packageJSON := `{
		"name": "test-project",
		"version": "1.0.0",
		"dependencies": {
			"express": "^4.18.0",
			"lodash": "^4.17.21",
			"axios": "^1.0.0"
		},
		"devDependencies": {
			"jest": "^29.0.0"
		}
	}`

	packagePath := filepath.Join(tempDir, "package.json")
	err = os.WriteFile(packagePath, []byte(packageJSON), 0644)
	require.NoError(t, err)

	licenses, err := checker.analyzeNpmLicenses(packagePath)
	require.NoError(t, err)

	assert.NotEmpty(t, licenses)
	assert.Len(t, licenses, 3) // Only dependencies, not devDependencies

	// Check that all expected packages are present
	packageNames := make(map[string]bool)
	for _, license := range licenses {
		packageNames[license.Dependency] = true
	}

	assert.True(t, packageNames["express"])
	assert.True(t, packageNames["lodash"])
	assert.True(t, packageNames["axios"])
}

func TestLicenseChecker_analyzeGoLicenses(t *testing.T) {
	checker := NewLicenseChecker()

	tempDir, err := os.MkdirTemp("", "license_test")
	require.NoError(t, err)
	defer os.RemoveAll(tempDir)

	goMod := `module test-project

go 1.19

require (
	github.com/gin-gonic/gin v1.9.0
	github.com/stretchr/testify v1.8.0
	golang.org/x/crypto v0.5.0
)

require (
	github.com/davecgh/go-spew v1.1.1 // indirect
)`

	goModPath := filepath.Join(tempDir, "go.mod")
	err = os.WriteFile(goModPath, []byte(goMod), 0644)
	require.NoError(t, err)

	licenses, err := checker.analyzeGoLicenses(goModPath)
	require.NoError(t, err)

	assert.NotEmpty(t, licenses)
	assert.Len(t, licenses, 3) // Only direct requires

	// Check that all expected packages are present
	packageNames := make(map[string]bool)
	for _, license := range licenses {
		packageNames[license.Dependency] = true
	}

	assert.True(t, packageNames["github.com/gin-gonic/gin"])
	assert.True(t, packageNames["github.com/stretchr/testify"])
	assert.True(t, packageNames["golang.org/x/crypto"])
}

func TestLicenseChecker_isLicenseCompatible(t *testing.T) {
	checker := NewLicenseChecker()

	tests := []struct {
		projectLicense string
		depLicense     string
		expected       bool
	}{
		{"MIT", "MIT", true},
		{"MIT", "Apache-2.0", true},
		{"MIT", "BSD-3-Clause", true},
		{"MIT", "GPL-3.0", false},
		{"Apache-2.0", "MIT", true},
		{"Apache-2.0", "GPL-3.0", false},
		{"GPL-3.0", "MIT", false},
		{"GPL-3.0", "GPL-3.0", true},
		{"unknown", "MIT", false},
	}

	for _, tt := range tests {
		t.Run(tt.projectLicense+"_"+tt.depLicense, func(t *testing.T) {
			result := checker.isLicenseCompatible(tt.projectLicense, tt.depLicense)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestLicenseChecker_getLicenseRisk(t *testing.T) {
	checker := NewLicenseChecker()

	tests := []struct {
		license      string
		expectedRisk string
	}{
		{"GPL-3.0", "high"},
		{"AGPL-3.0", "high"},
		{"LGPL-3.0", "medium"},
		{"MPL-2.0", "medium"},
		{"MIT", "low"},
		{"Apache-2.0", "low"},
		{"unknown-license", "low"}, // Default to low
	}

	for _, tt := range tests {
		t.Run(tt.license, func(t *testing.T) {
			risk := checker.getLicenseRisk(tt.license)
			assert.Equal(t, tt.expectedRisk, risk)
		})
	}
}

func TestLicenseChecker_getLicenseConflictSeverity(t *testing.T) {
	checker := NewLicenseChecker()

	tests := []struct {
		license1 string
		license2 string
		expected string
	}{
		{"GPL-3.0", "MIT", "critical"},  // High risk license
		{"MIT", "AGPL-3.0", "critical"}, // High risk license
		{"LGPL-3.0", "MIT", "high"},     // Medium risk license
		{"MIT", "MPL-2.0", "high"},      // Medium risk license
		{"MIT", "Apache-2.0", "medium"}, // Both low risk
	}

	for _, tt := range tests {
		t.Run(tt.license1+"_"+tt.license2, func(t *testing.T) {
			severity := checker.getLicenseConflictSeverity(tt.license1, tt.license2)
			assert.Equal(t, tt.expected, severity)
		})
	}
}

func TestLicenseChecker_HasLicenseFile(t *testing.T) {
	checker := NewLicenseChecker()

	tempDir, err := os.MkdirTemp("", "license_test")
	require.NoError(t, err)
	defer os.RemoveAll(tempDir)

	// Test without license file
	assert.False(t, checker.HasLicenseFile(tempDir))

	// Test with LICENSE file
	err = os.WriteFile(filepath.Join(tempDir, "LICENSE"), []byte("MIT License"), 0644)
	require.NoError(t, err)
	assert.True(t, checker.HasLicenseFile(tempDir))

	// Clean up and test with LICENSE.txt
	if err := os.Remove(filepath.Join(tempDir, "LICENSE")); err != nil {
		t.Errorf("Failed to remove LICENSE file: %v", err)
	}
	err = os.WriteFile(filepath.Join(tempDir, "LICENSE.txt"), []byte("MIT License"), 0644)
	require.NoError(t, err)
	assert.True(t, checker.HasLicenseFile(tempDir))
}

func TestLicenseChecker_projectExists(t *testing.T) {
	checker := NewLicenseChecker()

	// Test with existing directory
	tempDir, err := os.MkdirTemp("", "license_test")
	require.NoError(t, err)
	defer os.RemoveAll(tempDir)

	err = checker.projectExists(tempDir)
	assert.NoError(t, err)

	// Test with non-existent directory
	err = checker.projectExists("/non/existent/path")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "project path does not exist")

	// Test with file instead of directory
	tempFile := filepath.Join(tempDir, "testfile")
	err = os.WriteFile(tempFile, []byte("test"), 0644)
	require.NoError(t, err)

	err = checker.projectExists(tempFile)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "project path is not a directory")
}

func TestLicenseChecker_getMockLicense(t *testing.T) {
	checker := NewLicenseChecker()

	// Test that same package name always returns same license
	license1 := checker.getMockLicense("express")
	license2 := checker.getMockLicense("express")
	assert.Equal(t, license1, license2)

	// Test that different package names can return different licenses
	license3 := checker.getMockLicense("lodash")
	// Note: They might be the same due to hash collision, but that's okay for mock data

	// Test that returned license is one of the expected values
	validLicenses := []string{"MIT", "Apache-2.0", "BSD-3-Clause", "GPL-3.0", "ISC"}
	assert.Contains(t, validLicenses, license1)
	assert.Contains(t, validLicenses, license3)
}

func TestGetDefaultCompatibilityMatrix(t *testing.T) {
	matrix := getDefaultCompatibilityMatrix()

	assert.NotNil(t, matrix)
	assert.Contains(t, matrix, "MIT")
	assert.Contains(t, matrix, "Apache-2.0")
	assert.Contains(t, matrix, "GPL-3.0")

	// Test MIT compatibility
	mitCompatible := matrix["MIT"]
	assert.Contains(t, mitCompatible, "MIT")
	assert.Contains(t, mitCompatible, "Apache-2.0")
	assert.Contains(t, mitCompatible, "BSD-3-Clause")
	assert.NotContains(t, mitCompatible, "GPL-3.0")
}

func TestGetDefaultRiskLevels(t *testing.T) {
	riskLevels := getDefaultRiskLevels()

	assert.NotNil(t, riskLevels)
	assert.Equal(t, "high", riskLevels["GPL-3.0"])
	assert.Equal(t, "high", riskLevels["AGPL-3.0"])
	assert.Equal(t, "medium", riskLevels["LGPL-3.0"])
	assert.Equal(t, "low", riskLevels["MIT"])
	assert.Equal(t, "low", riskLevels["Apache-2.0"])
}
