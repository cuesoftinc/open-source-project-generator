// Package license provides license compatibility checking and auditing functionality
// for the Open Source Project Generator audit engine.
package license

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/cuesoftinc/open-source-project-generator/pkg/interfaces"
)

// LicenseChecker handles license compatibility checking and auditing
type LicenseChecker struct {
	// compatibilityMatrix defines which licenses are compatible with each other
	compatibilityMatrix map[string][]string
	// riskLevels defines the risk level for each license type
	riskLevels map[string]string
}

// NewLicenseChecker creates a new license checker instance
func NewLicenseChecker() *LicenseChecker {
	return &LicenseChecker{
		compatibilityMatrix: getDefaultCompatibilityMatrix(),
		riskLevels:          getDefaultRiskLevels(),
	}
}

// AuditLicenses performs license auditing
func (lc *LicenseChecker) AuditLicenses(path string) (*interfaces.LicenseAuditResult, error) {
	if err := lc.projectExists(path); err != nil {
		return nil, err
	}

	result := &interfaces.LicenseAuditResult{
		Score:           100.0,
		Compatible:      true,
		Licenses:        []interfaces.LicenseInfo{},
		Conflicts:       []interfaces.LicenseInfo{},
		Recommendations: []string{},
	}

	// Check license compatibility
	compatibilityResult, err := lc.CheckLicenseCompatibility(path)
	if err != nil {
		return nil, fmt.Errorf("license compatibility check failed: %w", err)
	}

	result.Compatible = compatibilityResult.Compatible

	// Convert DependencyLicense to LicenseInfo
	for _, dep := range compatibilityResult.Dependencies {
		licenseInfo := interfaces.LicenseInfo{
			Name:       dep.License,
			SPDXID:     dep.SPDXID,
			Package:    dep.Dependency,
			Compatible: dep.Compatible,
		}
		result.Licenses = append(result.Licenses, licenseInfo)

		// Find conflicts
		if !dep.Compatible {
			result.Conflicts = append(result.Conflicts, licenseInfo)
		}
	}

	// Calculate license score
	if len(result.Licenses) > 0 {
		compatibleCount := len(result.Licenses) - len(result.Conflicts)
		result.Score = float64(compatibleCount) / float64(len(result.Licenses)) * 100
	}

	// Recommendations will be generated by the calling engine
	result.Recommendations = []string{}

	return result, nil
}

// CheckLicenseCompatibility checks license compatibility
func (lc *LicenseChecker) CheckLicenseCompatibility(path string) (*interfaces.LicenseCompatibilityResult, error) {
	result := &interfaces.LicenseCompatibilityResult{
		Compatible:      true,
		ProjectLicense:  "unknown",
		Dependencies:    []interfaces.DependencyLicense{},
		Conflicts:       []interfaces.LicenseConflict{},
		Recommendations: []interfaces.LicenseRecommendation{},
		Summary: interfaces.LicenseCompatibilitySummary{
			TotalLicenses:      0,
			CompatibleLicenses: 0,
			Conflicts:          0,
			RiskLevel:          "low",
		},
	}

	// Detect project license
	projectLicense, err := lc.detectProjectLicense(path)
	if err == nil {
		result.ProjectLicense = projectLicense
	}

	// Analyze dependency licenses
	dependencies, err := lc.analyzeDependencyLicenses(path)
	if err != nil {
		return nil, fmt.Errorf("dependency license analysis failed: %w", err)
	}

	result.Dependencies = dependencies
	result.Summary.TotalLicenses = len(dependencies)

	// Check compatibility
	for _, dep := range dependencies {
		if lc.isLicenseCompatible(result.ProjectLicense, dep.License) {
			result.Summary.CompatibleLicenses++
		} else {
			result.Compatible = false
			result.Conflicts = append(result.Conflicts, interfaces.LicenseConflict{
				Dependency1: "project",
				License1:    result.ProjectLicense,
				Dependency2: dep.Dependency,
				License2:    dep.License,
				Reason:      "License incompatibility",
				Severity:    lc.getLicenseConflictSeverity(result.ProjectLicense, dep.License),
				Resolution:  "Consider changing project license or replacing dependency",
			})
			result.Summary.Conflicts++
		}
	}

	// Determine risk level
	if result.Summary.Conflicts > 0 {
		result.Summary.RiskLevel = "high"
	} else if result.ProjectLicense == "unknown" {
		result.Summary.RiskLevel = "medium"
	}

	return result, nil
}

// ScanLicenseViolations scans for license violations
func (lc *LicenseChecker) ScanLicenseViolations(path string) (*interfaces.LicenseViolationResult, error) {
	result := &interfaces.LicenseViolationResult{
		Violations: []interfaces.LicenseViolation{},
		Summary: interfaces.LicenseViolationSummary{
			TotalViolations:    0,
			CriticalViolations: 0,
			HighViolations:     0,
			MediumViolations:   0,
			LowViolations:      0,
		},
	}

	// Check for missing license files
	if !lc.HasLicenseFile(path) {
		result.Violations = append(result.Violations, interfaces.LicenseViolation{
			Type:       "missing",
			Dependency: "project",
			License:    "none",
			Violation:  "No license file found in project",
			Severity:   "high",
			Resolution: "Add a LICENSE file to the project root",
		})
	}

	// Check dependency licenses
	compatibilityResult, err := lc.CheckLicenseCompatibility(path)
	if err == nil {
		for _, conflict := range compatibilityResult.Conflicts {
			result.Violations = append(result.Violations, interfaces.LicenseViolation{
				Type:       "incompatible",
				Dependency: conflict.Dependency2,
				License:    conflict.License2,
				Violation:  conflict.Reason,
				Severity:   conflict.Severity,
				Resolution: conflict.Resolution,
			})
		}
	}

	// Update summary
	for _, violation := range result.Violations {
		result.Summary.TotalViolations++
		switch violation.Severity {
		case "critical":
			result.Summary.CriticalViolations++
		case "high":
			result.Summary.HighViolations++
		case "medium":
			result.Summary.MediumViolations++
		case "low":
			result.Summary.LowViolations++
		}
	}

	return result, nil
}

// detectProjectLicense detects the project's license
func (lc *LicenseChecker) detectProjectLicense(path string) (string, error) {
	licenseFiles := []string{"LICENSE", "LICENSE.txt", "LICENSE.md", "COPYING"}

	for _, licenseFile := range licenseFiles {
		filePath := filepath.Join(path, licenseFile)
		if _, err := os.Stat(filePath); err == nil {
			// #nosec G304 - Audit tool legitimately reads files for analysis
			content, err := os.ReadFile(filePath)
			if err != nil {
				continue
			}

			// Simple license detection based on content
			contentStr := string(content)
			if strings.Contains(contentStr, "MIT License") {
				return "MIT", nil
			} else if strings.Contains(contentStr, "Apache License") {
				return "Apache-2.0", nil
			} else if strings.Contains(contentStr, "GNU General Public License") {
				return "GPL-3.0", nil
			} else if strings.Contains(contentStr, "BSD") {
				return "BSD-3-Clause", nil
			}

			return "custom", nil
		}
	}

	return "unknown", fmt.Errorf("no license file found")
}

// analyzeDependencyLicenses analyzes licenses of project dependencies
func (lc *LicenseChecker) analyzeDependencyLicenses(path string) ([]interfaces.DependencyLicense, error) {
	var licenses []interfaces.DependencyLicense

	// This is a simplified implementation
	// In a real implementation, you would query package registries for license information

	// Check package.json for npm dependencies
	if lc.hasFile(path, "package.json") {
		npmLicenses, err := lc.analyzeNpmLicenses(filepath.Join(path, "package.json"))
		if err == nil {
			licenses = append(licenses, npmLicenses...)
		}
	}

	// Check go.mod for Go dependencies
	if lc.hasFile(path, "go.mod") {
		goLicenses, err := lc.analyzeGoLicenses(filepath.Join(path, "go.mod"))
		if err == nil {
			licenses = append(licenses, goLicenses...)
		}
	}

	return licenses, nil
}

// analyzeNpmLicenses analyzes npm package licenses
func (lc *LicenseChecker) analyzeNpmLicenses(filePath string) ([]interfaces.DependencyLicense, error) {
	var licenses []interfaces.DependencyLicense

	// This is a simplified implementation
	// In a real implementation, you would parse package.json and query npm registry

	// #nosec G304 - Audit tool legitimately reads files for analysis
	content, err := os.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	// Simple extraction of dependency names
	lines := strings.Split(string(content), "\n")
	inDeps := false

	for _, line := range lines {
		if strings.Contains(line, "\"dependencies\"") {
			inDeps = true
			continue
		}
		if inDeps && strings.Contains(line, "}") {
			break
		}
		if inDeps && strings.Contains(line, "\"") {
			parts := strings.Split(line, "\"")
			if len(parts) >= 2 {
				pkgName := parts[1]
				// Mock license data (in real implementation, query npm registry)
				license := lc.getMockLicense(pkgName)
				licenses = append(licenses, interfaces.DependencyLicense{
					Dependency: pkgName,
					License:    license,
					SPDXID:     license,
					Compatible: lc.isLicenseCompatible("MIT", license), // Assume MIT project license
					Risk:       lc.getLicenseRisk(license),
				})
			}
		}
	}

	return licenses, nil
}

// analyzeGoLicenses analyzes Go module licenses
func (lc *LicenseChecker) analyzeGoLicenses(filePath string) ([]interfaces.DependencyLicense, error) {
	var licenses []interfaces.DependencyLicense

	// #nosec G304 - Audit tool legitimately reads files for analysis
	content, err := os.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	lines := strings.Split(string(content), "\n")
	inRequireBlock := false

	for _, line := range lines {
		line = strings.TrimSpace(line)

		// Handle single-line require
		if strings.HasPrefix(line, "require ") && !strings.Contains(line, "(") {
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				pkgName := parts[1]
				// Mock license data (in real implementation, query Go module proxy)
				license := lc.getMockLicense(pkgName)
				licenses = append(licenses, interfaces.DependencyLicense{
					Dependency: pkgName,
					License:    license,
					SPDXID:     license,
					Compatible: lc.isLicenseCompatible("MIT", license), // Assume MIT project license
					Risk:       lc.getLicenseRisk(license),
				})
			}
			continue
		}

		// Handle multi-line require block
		if line == "require (" {
			inRequireBlock = true
			continue
		}

		if inRequireBlock {
			if line == ")" {
				inRequireBlock = false
				continue
			}

			// Skip comments and empty lines
			if strings.HasPrefix(line, "//") || line == "" {
				continue
			}

			// Parse dependency line
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				pkgName := parts[0]
				// Skip indirect dependencies for this test
				if !strings.Contains(line, "// indirect") {
					// Mock license data (in real implementation, query Go module proxy)
					license := lc.getMockLicense(pkgName)
					licenses = append(licenses, interfaces.DependencyLicense{
						Dependency: pkgName,
						License:    license,
						SPDXID:     license,
						Compatible: lc.isLicenseCompatible("MIT", license), // Assume MIT project license
						Risk:       lc.getLicenseRisk(license),
					})
				}
			}
		}
	}

	return licenses, nil
}

// getMockLicense returns a mock license for demonstration
func (lc *LicenseChecker) getMockLicense(packageName string) string {
	// Mock license assignment based on package name hash
	licenses := []string{"MIT", "Apache-2.0", "BSD-3-Clause", "GPL-3.0", "ISC"}
	hash := 0
	for _, c := range packageName {
		hash += int(c)
	}
	return licenses[hash%len(licenses)]
}

// isLicenseCompatible checks if two licenses are compatible
func (lc *LicenseChecker) isLicenseCompatible(projectLicense, depLicense string) bool {
	compatible, exists := lc.compatibilityMatrix[projectLicense]
	if !exists {
		return false // Unknown license, assume incompatible
	}

	for _, compat := range compatible {
		if compat == depLicense {
			return true
		}
	}

	return false
}

// getLicenseRisk returns the risk level for a license
func (lc *LicenseChecker) getLicenseRisk(license string) string {
	if risk, exists := lc.riskLevels[license]; exists {
		return risk
	}
	return "low" // Default to low risk for unknown licenses
}

// getLicenseConflictSeverity returns the severity of a license conflict
func (lc *LicenseChecker) getLicenseConflictSeverity(license1, license2 string) string {
	if lc.getLicenseRisk(license1) == "high" || lc.getLicenseRisk(license2) == "high" {
		return "critical"
	}
	if lc.getLicenseRisk(license1) == "medium" || lc.getLicenseRisk(license2) == "medium" {
		return "high"
	}
	return "medium"
}

// HasLicenseFile checks if a LICENSE file exists
func (lc *LicenseChecker) HasLicenseFile(path string) bool {
	licenseFiles := []string{"LICENSE", "LICENSE.txt", "LICENSE.md", "COPYING", "license", "license.txt"}
	for _, license := range licenseFiles {
		if lc.hasFile(path, license) {
			return true
		}
	}
	return false
}

// hasFile checks if a file exists in the given path
func (lc *LicenseChecker) hasFile(path, filename string) bool {
	filePath := filepath.Join(path, filename)
	_, err := os.Stat(filePath)
	return err == nil
}

// projectExists checks if the project path exists and is a directory
func (lc *LicenseChecker) projectExists(path string) error {
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("project path does not exist: %s", path)
		}
		return fmt.Errorf("🚫 %s %s",
			"Unable to access project path.",
			"Check if the directory exists and has proper permissions")
	}

	if !info.IsDir() {
		return fmt.Errorf("project path is not a directory: %s", path)
	}

	return nil
}

// getDefaultCompatibilityMatrix returns the default license compatibility matrix
func getDefaultCompatibilityMatrix() map[string][]string {
	return map[string][]string{
		"MIT":          {"MIT", "Apache-2.0", "BSD-3-Clause", "ISC"},
		"Apache-2.0":   {"MIT", "Apache-2.0", "BSD-3-Clause"},
		"BSD-3-Clause": {"MIT", "Apache-2.0", "BSD-3-Clause", "ISC"},
		"GPL-3.0":      {"GPL-3.0", "LGPL-3.0"},
		"ISC":          {"MIT", "Apache-2.0", "BSD-3-Clause", "ISC"},
	}
}

// getDefaultRiskLevels returns the default license risk levels
func getDefaultRiskLevels() map[string]string {
	return map[string]string{
		"GPL-3.0":      "high",
		"AGPL-3.0":     "high",
		"SSPL-1.0":     "high",
		"LGPL-3.0":     "medium",
		"MPL-2.0":      "medium",
		"MIT":          "low",
		"Apache-2.0":   "low",
		"BSD-3-Clause": "low",
		"ISC":          "low",
	}
}
